1)基础配置
    项目运行时浏览器自动打开，package.json里serve后面加上--open
    关闭eslint校验工具 vue.config
    src文件夹的别名
2)非路由组件
3）路由组件
    安装vue-router
    路由组件放在views或者pages中
    配置路由放在router文件夹中index.js
    在main.js中注册
    在根组件中给路由出口 router-view

    $route:一般获取路由信息（路径，query，params
    $router:一般进行编程式导航进行路由跳转（push|replace)区别：能否记录历史信息
    注册完路由，不管是路由组件还是非路由组件都会有$route 和$router属性

4）路由的跳转
    路由的跳转两种形式：
    1、声明式导航router-link,to属性表示向哪里跳转
    2、编程式导航push|replace：可以做声明式导航做的，也可以在跳转的过程中完成一些其他的业务逻辑
5)路由元信息控制footer的显示与隐藏
    在配置路由时可以携带meta属性，从而$route中就会多一个信息meta。
    通过meta标签，和v-show控制显示与隐藏
6)路由传参query和params
    query:不需要配置路由，也不需要进行占位，不属于路径中的一部分
    params：属于路径中的一部分，需要配置路由进行占位

    三种写法
        1、字符串写法
        2、模板字符串
        3、常用的：对象写法。params传参时在路由配置项中定义name
    面试题
        1、路由传递参数的对象写法，path能否结合params一起使用？
            对象传参，可以有name和path两种传递方式，但是params只能和name一起使用
        2、如何指定params参数可传可不传？
            如果已经在路由配置中占位，但是不传递params参数，那么路径会出现问题，
            可以在占位后面加上？，表示params参数可传可不传。
        3、params参数可传可不传，但是如果传递的是空串，怎么解决？
            params传空串，url同样会出现问题。’‘||undefined解决
        4、路由组件能否传递props数据？
            可以，有三种写法。常用，在路由配置中props:（$route）=>{keyword:$route.params.keyword,k:$route.query.k}
            在组件中接收props:['keyword','k']
7)重写push|replace方法
    why：本身的push方法，如果多次传递同一个params参数，将会抛出错误
    solve：因为push（参数对象，()=>{},()=>{}）接受三个参数，还需要传递成功和失败的回调函数。
    重写push方法。push在VueRouter的原型对象中。
    call和apply的区别：相同点：都可以调用函数一次，篡改函数的上下文对象
                        区别：call传递的参数用逗号隔开，apply传递参数为一个数组
8)home静态页面
    三级联动注册成为全局组件
9)axios二次封装
    发送请求：XMLHttpRequest、fetch、JQ，axios
    why:二次封装，主要是使用请求拦截器和相应拦截器。请求之前处理业务和获取结果以后处理业务
    在api下的request.js进行二次封装axios
10)接口统一管理

11）跨域问题：协议、域名、端口号不同
    解决跨域：JSONP，CROS，代理服务器
12)发请求进度条往前走nprogress
    安装
    引入包，样式
    nprogress携带一些方法，开始和结束
    在请求拦截器开始进度条，相应拦截器结束进度条
13)vuex状态管理器
    管理项目中公用的数据
    //state:仓库存储数据的地方
    const state ={};
    //mutations:修改state的唯一手段 
    const mutations ={};
    //actions:处理actions，可以书写自己的业务
    const actions = {};
    //getters:理解为计算属性，用于简化仓库数据，让组件获取仓库数据更加方便
    const getters ={};
14）vuex模块化管理：数据都集中在一个对象上数据过多很难管理
    index引入modules
    分成小仓库进行管理数据
15)三级联动展示数据
    在mounted中发送请求，$store.dispatch()
    在action中发送请求,并且通过commit解构出数据传递给mutations
    mutations中修改state中的数据：初始值=发i请求获取的data
    state中传递数据和初始值。

    组件中拿到数据进行展示
    1、{mapState}
    2、computed中取到state中的数据...mapState
16)卡顿现象：用户的行为操作过快，没有给浏览器充分的时间进行解析，因此如果某操作包含大量的业务逻辑，将会导致页面的卡顿。
17）防抖与节流
    防抖：前面所有的触发都被取消，最后一次执行在规定时间内的才会被触发。如果快速的触发只会执行一次
    例如搜索，一般不会输入一个字符就会发一次请求进行搜索，而是用户输入一段文字以后触发一次请求。
    使用lodash中的防抖函数_.debounce(fun,wait),

    节流：规定的时间范围内不会重复触发，只有大于时间间隔才会触发回调，频繁触发变为少量触发(平a)throttle
18)三级联动组件的路由跳转和传递参数
    点击一级、二级、三级=>Home模块跳转到search模块，把用户选中的产品（name和id）在路由跳转的时候进行传递
    声明式导航由组件实现，一下子创建了好多组件，会导致页面卡顿
    编程式导航：如果给每个a绑定事件，也会回调过多
    因此使用编程式导航和事件委派，给父元素绑定事件
    怎么判断点击的是a？首先获取到a使用事件对象e.target，再用自定义属性判断
    怎么判断点击的是几级标签？同样给每级绑定自定义属性，通过target中的dataset获取，然后解构出其中的参数，最后判断是几级
19）search中的三级分类和过渡动画
    路由守卫：和首页共用一个三级联动组件，但是首页不需要显示和隐藏，因此需要判断一下当前的路由name是否为首页
    过渡动画：只有组件和元素包含由v-if和v-show才可以使用过渡动画
20)每次使用三级联动的组件，都会发请求，就会重复请求
    在app根组件中的mounted只会执行一次，因此在根组件挂载就发请求并且从仓库中派发数据
21）合并参数
    因为发送搜索请求以后要想服务器传递参数，参数中既有query参数，也有params参数
    --增加一个判断条件，如果有p参数就加上，如果有q就加上
22)使用mockjs模拟数据完成首页
    1、src中准备mock文件夹
    2、准备好数据
    3、把需要的图片资源放在public中
    4、mockServe.js模拟数据：图片和json不需要对外暴露export就可以import
    5、在入口文件执行一次
23)发i请求得到轮播图数据
    1、重新封装一个发到mock的axios
    2、在mounted中发情请求
    3、vuex中接受请求数据放在仓库中
    4、页面中拿到仓库中的数据:先import mapstate，再computed，传入state，拿到state中的数据
24）swiper：
25)组件间通信。
    props，父子组件通信。父中子组件标签绑定数据，子组件通过props接收
    $on $emit,子穿父
    全局事件总线
    pubsub
26)search的动态展示数据
    写api，post请求，必须携带参数，或者空对象
    组件中dispatch
    store中写actions，mutations，state
    getters属性简化数据（数据结构比较复杂，层数嵌套过多时）
        getter中函数携带的参数为当前仓库的state数据
    mapGetters映射数据
    之后动态展示数据
27）发送post请求，收集数据带给服务器
    在发送请求之前，把数据准备好带给服务器。beforeMount(),
28)当路由发生变化，再次发送请求进行搜索，在watch中监听属性变化
29)面包屑：
    v-if
30)搜索框，如果删除面包屑，搜索框文字删除。搜索框在兄弟组件中，因此要传递参数
    组件间信息传递：1.props 2.自定义事件，子给父 3.插槽 4.$bus 5.vuex 6.pubsub
    $bus:在main.js中，beforeCreate(){vue.pro.$bus = this}
    发出通知的search组件：this.$bus.$emit("事件");
    接收通知header中的搜素框：mounted（）{this.$bus.$on("事件",fun(){清楚关键字})}
31)品牌面包屑：在searchselecter里点击品牌，显示面包屑
    1.点击品牌，发送请求：由于是父在整理参数，应该把参数传递给父组件，由父组件发送给请求。
    2.使用自定义事件$emit:父组件中绑定自定义事件，回调中接收子组件传递的数据
                        子组件使用$emit("自定义事件"，要传递的数据)向父组件传递数据
    3.父组件中整理参数，发送请求
    4.添加和删除面包屑：添加面包屑时数组去重indexOf，删除面包屑使用删除数组splice（index，1）
32）重点：数据列表排序操作：
    排序的类别：综合排序和按照价格排序，分别有升序和降序
33）分页器：
    pageNo当前页、
    pageSize当前页面展示的数据条数，
    total总共的数据，
    totalPage一共有几页，
    continues中间联系的页码个数5/7
34)分页器内部逻辑：
    先从父组件中接收动态数据：：，props
    完成分页器的内部逻辑，计算属性
35）展示分页器的数据，子给父通知，使用自定义事件
    父组件中的子结构：自定义事件，method：自定义事件接收子组件传回来的数据pageNo。。。
    把pageNo传给服务器
36)添加路由组件Details
37)滚动事件，路由跳转后页面滚动到最上面
    路由统一管理：分文件管理，routes.js中引入每一个路由，并且通过export暴露。index中引入routes.js，并且向外暴露
38)排他
39)加入购物车

40)路由跳转和参数传递：
    H5新增特性：
    ·新增了一些标签：<main><nav><footer>...
    `新增Css  animation transition transform
    ·本地存储和会话存储 给浏览器新增了存储功能
        ·Local-Storage 本地存储是持久化的，浏览器关闭以后数据还在，是有上限的 5M
        ·Session-Storage 会话存储不是持久化的，浏览器关闭以后，会话结束，数据消失
    ·多媒体：radio audio 
    ·画布canvas
    ·直播

    react和vue都是单页应用

    因此在展示购物车，传递参数时，简单的数据直接由query传递过去。较为复杂的数据{}通过会话进行存储。会话结束时数据消失。
    不管是本地存储还是会话存储存储的都是字符串
41)添加到购物车（需要用户的id才可以加上。游客登陆的情况，随机生成一个id。
    1、写api
    2、store中添加shopcart组件，使用uuid组件（utill中封装），返回一个函数，函数返回结果为随机生成的uuid
        由于添加购物车需要人的id，而没有id就获取不到购物车的数据。因此使用uuid获取游客身份
        而向服务器发送请求的接口中不需要传入身份id参数，此时通过添加请求头的方式向服务器传递id参数
    3、在请求拦截器中添加请求头uuid
        在utill中暴露一个函数，生成uuid，由于一次访问以后下次不能变，所以永久存储，使用localstorage
        在state仓库中接收uuid函数，接收返回值
        把仓库中的uuid在请求头中携带给服务器，在请求拦截器中，携带一个uuid

42)完成删除购物车的操作
    1.写api
    2.vuex中发送请求，携带要删除产品的id
    3 如果请求成功,dispatch,重新发请求更新页面。失败xx
43）修改checked的状态
    ·写api，传递id和checked状态
    ·vuex中写请求，携带id和状态，不用返回数据，则使用promise.reject
    ·页面中try catch派发请求，把event.target点击的checked属性内容，计算为checked参数。请求成功重新获取页面数据
44)删除所有数据：没有接口，只有删除一条数据的接口
    ·页面中绑定一个点击事件，点击事件派发自定义的actions
    ·自定义actions携带context参数，相当于一个小仓库，包含{commit//提交mutations修改state，dispatch，getters，state}
    ·循环遍历每一个加入购物车内的商品，如果isChecked属性为1，那么diapatch一个删除请求
    ·因为遍历好多次，则会产生许多dispatch请求，将会返回许多个promise。因此使用promise.all([p1,p2,p3])
    ·promise.all接收一个数组，数组内为返回的promise对象。如果有一个promise对象不成功则为不成功
    ·带回的结果传递给页面中的点击事件
45)全选购物车，没有接口，只有携带状态进行修改的单个接口
    ·同样操作，界面绑定单击事件，派发自定义actions，携带参数为全选按钮的勾选状态，把isChecked带去
    ·自定义actions，循环遍历购物车中的item，把每一个checked框的状态都改为全选按钮一样的选中状态。
    ·Promise.all返回所有结果

46）登录注册
    ·完成静态
    ·双向绑定表单数据
    ·验证码请求
    ·完成注册请求,跳转到登陆页面
47）登录
    ·阻止默认行为，prevent
    ·收集用户名和密码
    ·api
    ·仓库发请求
    ·服务器返回数据，登陆成功以后，携带一个token，服务器给用户的唯一标识，应该在浏览器中永久存储，而vuex存储数据不是持久化的，刷新以后就会消失，因此token不能存在仓库中
    ·登陆成功，路由跳转到主页

    ·token校验，带着token向服务器发i请求，获取用户信息
        ·api
        ·向服务器发送请求，但是不要求携带参数,所以将token存储到请求头中，每次发i请求都带给服务器
        ·获取到用户信息，v-if展示

48）退出登录，清除用户数据，清除token
49)导航守卫  如果路由发生变化，则需要通过守卫，看看是否可以跳，符合条件才可以跳转
    （如果用户已经登陆，则不能回到注册登录
    如果用户没有登录，则不能查看自己的购物车界面）

    1.全局守卫：前置、后置
     router.beforeEach((to,from,next)=>{
         to:将往哪里跳转
         from：从哪里来的
         next：一个函数next（）表示放行，next('/')表示向哪里放行

     })
    2·路由独享守卫
    3·组件内守卫

50)不使用vuex发送请求：
    ·接口统一暴露main.js中统一接收暴露所有api
    ·import *as API from '@/api'即把所有的请求接口封装为一个对象包含所有api接口
    ·beforeCreate挂载前在vue的原型对象中添加为$API方法，所有的组件中都会包含$API
    ·则添加方法，发送请求

    携带许许多多的参数给服务器发送post请求,封装成一个对象带给服务器
51）按需引入element ui
    挂载在原型上
    全局引入组件的方式

    生成一个二维码qrcode
52)展示二维码开始支付，发送查询支付成功与否的请求，需要一直发送
    长轮询
    短轮询：http，之发送一次轮询
        使用setInerval隔一段时间发送一次请求
53）注册二级路由
    ·拆分组件
    ·引入路由，children中注册路由[{},{},{}]
    ·path /代表一级，因此二级路由不带斜杠
    ·router-link完成二级路由跳转
    ·router-view完成二级路由占位，二级路由的出口
54)导航守卫考虑用户体验
    未登录不能跳转的路由，存储给query参数。/把未登录的时候向去而没有去成的信息，存储于地址栏中【路由】通过redirect
    在登陆成功进行跳转的时候，判断是否有query参数，如果没有则进入home主页，如果有则进入query参数中的组件
55)已经登陆的用户不能直接去的地方：支付成功的界面
    ·全局守卫处理的场景：未登录访问：访问到交易、支付、用户中心等相关页面跳转到登陆页面
    ·路由独享守卫：某些组件间只能由前一组件跳转来：
        从购物车才能去交易页面、从交易页面才能跳转到支付页面、从支付页面才能跳转到支付成功页面
        在路由配置中直接配置beforeEnter
        to from next()    next(false):终端当前的导航，如果浏览器的url改变，用户手动修改，url地址会重置到from对应的地址
    ·组件内的守卫

56)图片懒加载：在很多图片没有加载出来之前，显示默认图片
    ·使用vue-lazyloader,安装
    ·在main.js中引入
    ·use使用组件
    ·需要一张loading图片
    ·需要v-loading

    自定义插件                  
    ·暴露为一个对象
    ·必须有install方法，引入插件，use插件的时候就会调用install方法
    ·install方法中，传入两个参数Vue和options
        可以给使用全局指令绑定自定义的方法（v-xxx使用）Vue.directive(options.name,(a,b)={})
        方法函数第一个默认参数为v-绑定的dom元素，
        第二个默认参数是dom包含的属性的所有对象.b中包含一个mofiers{}，表示修饰符。    .prevent事件修饰符，阻止默认事件
    ·对外暴露
57)表单验证：注册页面的表单验证
58）路由懒加载  当用户访问路由的时候再加载。使用vue异步组件和webpack代码分割的功能
59）项目打包 npm run build  打包在dist文件夹
    项目打包后，代码都是经过压缩加密的，如果运行的时候报错，通过错误信息无法准确知道是哪里的代码报错
    有了map以后，就可以像未加密的代码一样，准确的输出是哪一行哪一列报错
    体积较大，config中配置


        


        